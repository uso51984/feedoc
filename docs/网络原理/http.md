<div class="title"> HTTP</div>

## 1. HTTP的历史

当前广泛使用的版本HTTP/1.1, 2015年又推出HTTP/2，但是要完全取代HTTP/1.1成为主流还需要漫长的时间

## 2. HTTP 协议的内容

一次HTTP协议通信会由客户端发起请求报文，然后由服务器端返回响应报文，而请求报文和响应报文的结构大致相同
请求报文包含请求行、请求头部、请求体

| 分类   | 值                 |
|--------|--------------------|
| 请求行： | 请求方法、URL、协议版本 |
| 请求头部 | 头部字段名： 值       |
| 数据   | 请求体              |

### 2.1. 请求头部

`key：value` 的形式，中间以冒号相隔，其中字段名不区分大小写。

#### 2.1.1. 头部字段类型分为4种

##### 2.1.1.1. 通用头部字段

1. `Cache-Control:`

控制缓存的，它可以接收多个参数，参数之间以逗号“，”分隔。虽然它是通用字段，但是请求头部和响应头部使用的参数值还是略有不同。

  + `no-cache：` no-cache值表明强制使用最新的值而不使用缓存值。则表示客户端不接收缓存过的响应，缓存服务器必须把客户端请求转发给源服务器。如果响应中包含no-cache，那么缓存服务器不能对响应资源进行缓存。
  + `no-store：` 当使用no-store时表示对应的报文中包含机密信息，也就意味着不应该缓存当前内容。
  + `no-transform：` 缓存不能改变主体的媒体类型，能防止缓存服务器压缩图片等操作。
  + `max-age：` 缓存有效期，单位为“秒”。客户端请求中包含max-age时，如果缓存资源的缓存时间比指定时间数值更小时则接收缓存资源，当值为0时，缓存服务器会把请求转发给源服务器。当响应报文中包含max-age，缓存服务器不再确认资源的有效性，而以max-age数值作为缓存保存时长。
  + `min-fresh：` 数值，单位为“秒”。要求缓存服务器在指定的时间内返回响应。
  + `only-if-cached：` 客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回值，也就是说不会向源服务器转发请求。响应头部常使用的值介绍如下。
  + `must-revalidate：` 本地缓存过期前可以使用，否则必须进行有效性校验。
  + `public：` 响应可被任何对象缓存，没有限制。
  + `private：` 响应只能被特定用户缓存，不能被其他用户使用。
  + `proxy-revalidate：` 仅适用于共享缓存，私有缓存时忽略。
  + `must-revalidate：` 缓存必须在使用之前验证旧资源的状态，如果过期则不可使用。

2. `Connection:`
* `Close` 当一方头部Connection值为Close时，代表关闭此次连接。
* `Keep-Alive` HTTP/1.1版本默认连接是持久的。对于之前的版本，需要指定值为Keep-Alive。

3. `Date:` 报文创建的时间日期。

##### 2.1.1.2. 请求头部

1. `accept:` 先看看一个HTTP请求头部accept字段的值，我们对照它进行分析： `accept:text/html,application/xhtml+xml,ap-plication/xml;q=0.9,image/webp,*/*;q=0.8accept` 字段可以设置多个值，每个值通过逗号“，”分隔（而不是分号“；”）

常见MIME类型与子类型

![](./img/img14.png )

2. `accept-charset:` 告知服务单客户端可以处理的字符集类型
3. `accept-encoding:` 客户端能够接收的编码方式，通常这个字段值会是某种压缩算法，比如gzip、compress。这个字段也支持权重设置，设置规则同accept。
4. `accept-language:` 客户端可以解析的自然语言，可以一次指定多个语言并设置权重，常用的值有zh-cn和en-us。
5. `authorization:` 用来告知服务器端认证信息。通常会在收到401状态码之后，在请求头部加入此字段，它的值是：type credentials
6. `host:` 用来告知服务器端请求资源所处的互联网主机名和端口号，如果不指定端口则会使用默认端口。这是唯一一个请求头部的必传字段。
7. `if-modified-sinceif-modified-since` : 这个字段值通常是一个日期，用来确认代理或客户端本地资源的有效性。服务器端在接收这个值后会与资源最近更新时间进行对比，如果在字段值指定的日期之后资源发生了更新，则服务器端会返回最新的资源，否则将返回304状态码响应客户端。
8. `if-none-match` 用于判断本地缓存是否有效。 `if-none-match` 通常存储的是上一次响应头部的 `ETag` 值，指定的值与资源的 `ETag` 值不一致时，服务器端才会处理请求。

##### 2.1.1.3. 响应头部字段

1. `age:` 字段值为数值，单位为秒，该字段能告知客户端服务器端在多久前创建了响应，若创建该响应的是缓存服务器，age值指的是缓存后的响应再次发起认证到认证完成的时间。代理创建响应必须加上age字段。
2. `ETag:` 服务器端在每次资源更新之后，都会生成一个唯一对应的标识，这个标识就是ETag值。ETag值的生成算法由服务器端自行决定，并没有统一的要求。ETag中有强ETag和弱ETag之分。强ETag只要资源发生变化就会改变值，而弱ETag值只用于提示资源是否相同。只有资源发生了较大改变的时候才会改变ETag值。它们可以通过值的格式来进行区分，弱ETag值相对于强ETag值会加上W/来表示。强ETag："asdfc12312"弱ETag：W/"asdfc12312"
3. `location:` 使用头部字段location可以引导请求发起方至某个与请求URL位置不同的资源，一般会配合3xx的状态码进行使用，比如302。
4. `www-authenticate:` 用于告知客户端当前服务器端可接收的认证方案，然后客户端可在authentication字段值中返回对应的值。

##### 2.1.1.4. 主体头部字段

主体头部字段是包含在请求报文和响应报文中的主体部分所使用的头部，用于补充与主体相关的信息。

1. `allow:` 用于通知客户端能够支持的HTTP请求方法。当服务器端接收到不支持的HTTP请求方法时，会响应状态信息405 Method Not Allowed，同时把支持的方法写入allow字段。
2. `content-encoding` : 用于告知客户端当前响应内容的编码方式，和请求头部字段accept-encoding的可选值一致，主要采用4种编码方式：gzip、compress、deflate、identity。3.`content-length表明主体部分的大小，单位为字节。
4. `content-type:` 与请求头部字段accept对应，表明响应主体内容的MIME类型。
5. `last-modified:` 资源的最后修改时间。同样是和缓存配合使用(一般会选文件的 `mtime`，表示文件内容的修改时间)。
6. `expires:` 值为失效日期，缓存服务器在接收到含有头部字段 `expires` 的响应之后，会以缓存来应答请求，在expires值指定的日期之前，响应的值会一直被缓存，如果过期则在收到新的请求之后重新向源服务器发起请求。

当头部 `cache-control` 值有 `max-age` 时，优先处理 `max-age` 。

#### 2.1.2. 其他字段

HTTP的头部信息是可以自定义的，服务器端和客户端都可以根据需要进行扩展。例如，
 * `X-Frame-Options` 就常作为响应头部字段，用来表示网站内容是否允许被嵌入其他网站的 `iframe` 中。当其值为deny时就表示禁止被作为iframe嵌入，这样可以有效地防止常见的点击劫持。

## 3. 主体部分

主体部分指的是请求体和响应体。头部字段content-type的值决定了主体的内容类型以及接收方对应的处理方式
REST API设计规范中的 `GET、POST、PUT、DELETE` 四种请求方法中，GET请求没有请求体，

### 3.1. 常用的POST请求头部content-type值类型一般有以下4种:。

1. `application/json` ：最常用的请求头部，表示请求体是序列化后的JSON格式的数据（对于前端开发者来说可以理解为对JSON对象执行了JSON.stringify之后的字符串），Date、Regex这些数据类型是无法直接提交给服务器端的。
2. `text/xml` ：前后端交互中很少使用XML格式的数据，在RPC远程进程调用时通常选择这种格式的数据来进行通信。
3. `multipart/form-data` ：form表单的默认头部字段，常用于上传文件。
4. `application/x-www-form-urlencoded` ：form表单结构，用于传递字符串参数的键值对，传递格式和URL传参方式很像，如key1=value1&key2=value2。
> 更多类型： https://tool.oschina.net/commons/

### 3.2. Cookie

#### 3.2.1. 请求报文中为cookie，响应报文中为set-cookie。
在set-cookie字段值中采取“名称=值”的形式，同时可以搭配属性来对其进行描述，可以使用的属性值包括下面5个。

1. `expires:` 通过这个属性可以指定数据的有效期，如果不设置此属性，那么当浏览器关闭的时候Cookie则会被清除。当Cookie从服务器端发出之后，就无法直接删除，只能通过覆盖已过期的Cookie来进行删除操作。
2. `path:` 用于指定Cookie发送范围的路径。如果不指定则为根路径。
3. `domain:` 指定Cookie适用的域名，匹配规则为结尾匹配，比如指定baidu.com之后，那么map.baidu.com、music.baidu.com域名都可以发送该Cookie。
4. `secure:` 当使用secure属性时表示只能在HTTPS安全连接中使用。没有此属性时，HTTP协议和HTTPS协议都可以操作该Cookie。
5. `HttpOnly:` 设置了该属性后浏览器端的JavaScript脚本程序将无法获得Cookie内容，从而无法轻易修改或删除。其主要目的是为了防止跨站脚本（XSS）对Cookie信息的窃取。

#### 3.2.2. Cookie的缺陷

* Cookie的大小是有限的，不同浏览器的限制会有所不同，早期浏览器对Cookie的限制大约在4KB左右，这就意味着客户端能存取的状态信息是非常有限的。
* Cookie会消耗网络带宽，因为Cookie是跟随域名和路径设定的，只要域名和路径相同，对于某些不需要Cookie的请求也会带上Cookie。
* Cookie是可以被禁用的，如果浏览器设置了安全策略禁止使用Cookie，那么服务器端设置Cookie将会失败。
* Cookie可能会被窃取或篡改。

## 4. HTTP/2 新功能

1. **多路复用：** 在 `HTTP/1.1` 协议中，为了避免浏览器过度消耗服务器端资源，所以限制了浏览器针对同一域名的并发请求数量，不同浏览器的限制数量在4～8不等，超过限制数量的请求将会被阻塞，延迟发送。 `HTTP/2` 则都是同时发送
2. **压缩报文：** `HTTP/2` 启用了强制性的压缩算法来压缩报文
3. **支持 `TLS` :** `HTTP/1.1` 由于无法保障数据的安全性，所以有了其升级版 `HTTPS` 协议，而 `HTTP/2` 中允许使用 `TLS 1.2` 或更新版本的协议来进行加密，使得通信更加安全。
4. **应用层协议协商:** 支持应用层协议协商（Application Layer Pro-tocol Negotiation，ALPN），以便客户端能够从HTTP/1.0、HTTP/1.1、HTTP/2乃至其他非HTTP协议中做出选择。
5. **服务器端推送**
6. **流控制:** 是接收端可以告知发送端能接收的数据大小，发送端在发送时进行计算，发送不超过设定值的数据。

## 5. HTTP/2.0 多路复用的基本原理以及解决的问题

HTTP/2 解决的问题，就是 HTTP/1.1 存在的问题：

1. **TCP 慢启动**：TCP 连接建立后，会经历一个先慢后快的发送过程，如果我们的资源都经过一次慢启动，对性能是不小的损耗。另外慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。
2. **多条 TCP 连接竞争带宽**：如果同时建立多条 TCP 连接，当带宽不足时就会竞争带宽，影响关键资源的下载。
3. **HTTP/1.1 队头阻塞：**尽管 HTTP/1.1 长连接可以通过一个 TCP 连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束前，其他请求只能处于阻塞状态。
为了解决以上的问题，HTTP/2 一个域名只能使用一个 TCP 长连接来传输数据，而且请求之间是并行的、非阻塞的，这就是多路复用。
实现原理：HTTP/2 引入了一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求 ID 的帧，这些帧在传输完成后根据 ID 组合对应的数据。


## 6. HTTP method都要哪些， 区别

HTTP/1.1包含:

1. `get` :
2. `head` : 服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。使用HEAD，可以：
  + 在不获取资源的情况下了解资源的情况（比如，判断其类型）；
  + 通过查看响应中的状态码，看看某个对象是否存在；
  + 通过查看首部，测试资源是否被修改了。
3. `post`
4. `options` : OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。
5. `put`
6. `delete`
7. `trace` : 客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子
8. `connect` "

## 7. get和post区别

### 7.1. 1.标注参考

| 项目          | GET                                                                                        | POST                                                                          |
|---------------|--------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| 后退按钮/刷新   | 无害                                                                                       | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。                                 |
| 书签          | 可收藏为书签                                                                                 | 不可收藏为书签                                                                  |
| 缓存          | 能被缓存                                                                                    | 不能缓存                                                                       |
| 编码类型       | application/x-www-form-urlencoded                                                          | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |
| 历史          | 参数保留在浏览器历史中。                                                                       | 参数保留在浏览器历史中。                                                          |
| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。        | 无限制                                                                         |
| 对数据类型的限制 | 只允许 ASCII 字符。                                                                          | 没有限制。也允许二进制数据。                                                        |
| 安全性         | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。                 |
| 可见性         | 数据在 URL 中对所有人都是可见的且有长度限制。                                                     | 数据不会显示在 URL 中。                                                          |

### 7.2. 2.副作用和幂等的概念

副作用指对服务器上的资源做改变，搜索是 `无副作用的` ， `注册是副作用` 的。
幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。因为前者是多了一个账号（资源），后者只是更新同一个资源。

在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。

### 7.3. GET 和 POST 报文上的区别

### 7.4. 其他知识
GET产生一个TCP数据包，而POST产生两个TCP数据包, 本质底层都是基于TCP协议

GET的请求，浏览器会把http header和data一并发送出去，服务器返回200（返回数据）
POST的请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200（返回数据）

## 8. 安全方法（Safe Methods）:

是指用户不管进行多少次操作，资源的状态都不会改变。比如说， `GET` 和 `HEAD` 方法仅能获取资源，而不会执行动作（action），这些方法属于“安全”的方法。 而 `POST` ， `PUT` ， `DELETE` 方法改变了资源的状态，可能会执行不安全的动作，使用者应该意识到这一点。

## 9. HTTP的缺点

1. 通信使用明文可能会被窃听
2. 不验证通信方的身份就可能遭遇伪装
4. 无法证明报文完整性，可能已遭篡改

## 10. 游览器在与服务器建立TCP连接后是否会在一个http请求完成后断开？ 什么情况会断开

持久连接：HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 `Connection: close` ，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。
默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 `Connection: close` 才会在请求完成后关闭连接

## 11. 一个TCP连接可以对应几个http请求

一个 TCP 连接是可以发送多个 HTTP 请求的

## 12. 为什么有时候刷新页面不需要重新建立SLL连接

TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。

## 13. 游览器对同一host建立TCP连接数量有限制吗？

跟浏览器设置相关(Chrome 最多允许对同一个 Host 建立六个 TCP 连接。)

## 14. http状态码， 含义


## 15. http 向 https 做重定向应该使用哪个状态码
一般用作 301 的较为多，但是也有使用 302，如果开启了 HSTS 则会使用 307

如知乎使用了 302，淘宝使用了 301


## 16. 什么情况会触发 options 请求
options 通常用于，在跨域请求前发起预检请求，以检测请求是否被服务器接受。
跨域请求中分为简单请求和预检请求两种，符合以下条件可视为简单请求：

使用的 HTTP method 是 GET POST HEAD
content-type 是 text/plain mutipart/form-data application/x-www-form-urlencode 三种之一
请求头只能包含这些
```c
- Accept
- Accept-Language
- Content-Language
- Content-Type （需要注意额外的限制）
- DPR
- Downlink
- Save-Data
- Viewport-Width
- Width
```
复制代码除去简单请求外，其他请求就会先触发预检请求。
常见的，比如使用

`content-Type 为 application/xml 或 text/xml 的 POST 请求`
设置自定义头，比如 X-JSON、X-MENGXIANHUI 等

预检请求返回的头部报文中有
```c
Access-Control-Allow-Origin： 服务器可接受的请求来源
Access-Control-Request-Method： 服务器实际请求所使用的 HTTP 方法
Access-Control-Request-Headers： 服务器实际请求所携带的自定义首部字段。
客户端基于从预检请求获得的信息来判断，是否继续执行跨域请求。
```
注意：跨域请求若想发送 `cookie` 信息，需要服务端设置 `resp.setHeader("Access-Control-Allow-Credentials","true");` 客户端设置 `withCredentials: true`


## 17. 网络协议分层
![](./img/img74.png )
