# js篇

## 作用域， 作用域链

### 1. 作用域：
代码的执行环境，全局执行环境就是全局作用域，函数的执行环境就是私有作用域，它们都是栈内存

* 私有作用域 ----> 函数执行都会形成一个私有作用域
* 全局作用域 ----> 页面一打开就会形成一个全局的作用域

### 2. 作用域链

代码在一个环境中执行时，会创建变量对象的一个作用域链（作用域形成的链条）

* 作用域链的前端，始终都是当前执行的代码所在环境的变量对象
* 作用域链中的下一个对象来自于外部环境，而在下一个变量对象则来自下一个外部环境，一直到全局执行环境
* 全局执行环境的变量对象始终都是作用域链上的最后一个对象
* 父函数的作用域在子函数的作用域链中，直到子函数被销毁，父级作用域才会释放
> 在看看闭包的作用域，只要存在函数内部调用，执行栈中就会保留父级函数和函数对于的作用域

ES5 只有全局作用域和函数作用域，没有块级作用域，es6 块级作用域

## 什么是包装对象
包装对象，只要是为了便于基本类型调用对象的方法。
包装对象有三种：`String Number Boolean`
这三种原始类型可以与实例对象进行自动转换，可把原始类型的值变成（包装成）对象，比如在字符串调用函数时，引擎会将原始类型的值转换成只读的包装对象，执行完函数后就销毁

## class 和 function 的区别
`class` 也是一个语法糖，本质还是基于原型链，`class` 语义化和编码上更加符合面向对象的思维。
对于 function 可以用 `call apply bind` 的方式来改变他的执行上下文，但是 `class` 却不可以，`class` 虽然本质上也是一个函数，但在转成 es5 （babel）做了一层代理，来禁止了这种行为。

1. `class` 中定义的方法不可用 `Object.keys()` 遍历
2. `class` 不可以定义私有的属性和方法， function 可以，只要不挂载在 this 作用域下就行
3. `class` 只能通过类名调用
4. `class` 的静态方法，this 指向类而非实例

## toString 和 valueOf 有什么区别

## String 和 Array 有哪些常用函数

## 判断数组的几种方法
题主要还是考察对原型链的理解

1. Array.isArray() ES6 api
1. obj instanceof Array 原型链查找
1. obj.constructor === Array 构造函数类型判断
1. Object.prototype.toString.call(obj) === '[object Array]' toString
1. 返回表示该对象的字符串，若这个方法没有被覆盖，那么默认返回 "[object type]" ，其中 type 是对象的类型。需要准确判断类型的话，建议使用这种方法

## js中不同进制怎么转换
10 进制转其他进制：Number(val).toString([2,8,10,16])
其他进制转成10进制：Number.parseInt("1101110",[2,8,10,16])
其他进制互转：先将其他进制转成 10 进制，在把 10 进制转成其他进制

## 对js处理二进制有了解吗

ArrayBuffer: 用来表示通用的、固定长度的原始二进制数据缓冲区，作为内存区域，可以存放多种类型的数据，它不能直接读写，只能通过视图来读写。
同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view），视图的作用是以指定格式解读二进制数据。目前有两种视图，一种是 TypedArray 视图，另一种是 DataView 视图，两者的区别主要是字节序，前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。
Blob: 也是存放二进制的容器，通过 FileReader 进行转换。
之前有做过简单的总结，大家可以看看：nodejs 二进制与Buffer
毕竟对这块应用的比较少，推荐一篇文章给大家 二进制数组

## 循环有几种方式，是否支持中断和默认情况下是否支持async/await

1. for 支持中断、支持异步事件
1. for of 支持中断、支持异步事件
1. for in 支持中断、支持异步事件
1. forEach 不支持中断、不支持异步事件
* map 不支持中断、不支持异步事件，支持异步处理方法：map 返回promise数组，在使用 Promise.all 一起处理异步事件数组
* reduce 不支持中断、不支持异步事件，支持异步处理方法：返回值返回 promise 对象
map 的比较简单就不写了，我写个 reduce 处理 async/await 的 demo
```js
const sleep = time => new Promise(res => setTimeout(res, time))
async function ff(){
    let aa = [1,2,3]
    let pp = await aa.reduce(async (re,val)=>{
        let r = await re;
        await sleep(3000)
        r += val;
        return Promise.resolve(r)
    },Promise.resolve(0))
    console.log(pp) // 6
}
ff()
```


## prototype 属性的作用

原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享. 好处，1. 节省了内存 2. 体现了实例对象之间的联系。

> 每个函数都有一个 `prototype` 属性，指向一个对象。对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型

``` js
function f() {}
typeof f.prototype // "object"

function Animal(name) {
    this.name = name;
}
Animal.prototype.color = 'white';

var cat1 = new Animal('大毛');
var cat2 = new Animal('二毛');

cat1.color // 'white'
cat2.color // 'white'
```

## constructor 属性

### 1. 简述
`prototype对象` 有一个 `constructor` 属性，默认指向 `prototype对象` 所在的 `构造函数` 。

``` js
function P() {}
P.prototype.constructor === P // true
```

constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。

``` js
function P() {}
var p = new P();

p.constructor === P // true
p.constructor === P.prototype.constructor // true
p.hasOwnProperty('constructor') // false
```

### 2. 作用

#### (1). 可以得知某个实例对象，到底是哪一个构造函数产生的。

``` js
function F() {};
var f = new F();

f.constructor === F // true
f.constructor === RegExp // false
```

#### (2). 可以从一个实例对象新建另一个实例。

``` js
function Constr() {}
var x = new Constr();

var y = new x.constructor();
y instanceof Constr // true
```

> instanceof: 运算符返回一个布尔值，表示对象是否为某个构造函数的实例。

## 原型、原型链

对象都有自己的原型对象( `prototype` )。任何一个对象，都可以充当其他对象的原型，而原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（ `prototype chain` ）：对象到原型，再到原型的原型，如果一层层地上溯，所有对象的原型最终都可以上溯到 `Object.prototype` ，即 `Object` 构造函数的 `prototype` 属性。也就是说，所有对象都继承了 `Object.prototype` 的属性。这就是所有对象都有 `valueOf和toString` 方法的原因，因为这是从 `Object.prototype` 继承的。 `Object.prototype` 的原型是 `null`

> `Object.getPrototypeOf` 方法返回参数对象的原型

## this

### 1.this简述
`this` a. 在构造函数之中，表示实例对象.b.this就是属性或方法“当前”所在的对象.c. 用apply, call, bind的情况略为特殊

``` js
this.property
```

> this就代表property属性当前所在的对象。

``` js
var person = {
    name: '张三',
    describe: function() {
        return '姓名：' + this.name;
    }
};
```

> this就代表person所在的对象。

### 2. 辨别函数内部this的指向

#### (1). 非严格模式: 根据调用环境上下文确定

``` html
<html lang="en">

<body>
    <p>hello word</p>
</body>
<script type="text/javascript">
    function getName() {
        console.log('this', this);
    }

    getName() // window

    const a = {
        name: 'xxx'
        getName
    }
    a.b() // object a
</script>

</html>
```

#### (2). 严格模式: 在严格模式下，未指定环境对象而调用函数，则this值不会转型为window。除非明确把函数添加到某个对象或者调用apply(), call(), bind，否则this值将是undefined。

``` html
<!DOCTYPE html>
<html lang="en">

<body>
    <p>hello word</p>
</body>
<script type="text/javascript">
    'use strict'
    // 验证第一条剪头函数this指向
    const getName = () => {
        console.log(this)
    }
    getName() // window

    function getAge() {
        console.log('this', this);
    }
    getAge() // undefined
    const obj = {
        name: 'xxx',
        age: 32,
        getAge,
        getName
    }
    obj.getAge() // object a
    obj.getName() // window
</script>

</html>
```

#### (3).apply(), call(), bind 指定

## new 命令的原理

1. 创建一个空对象，作为将要返回的对象实例。
2. 将这个空对象的原型，指向构造函数的prototype属性。
3. 将这个空对象赋值给函数内部的this关键字。
4. 开始执行构造函数内部的代码。

## 宿主对象（host objects）和原生对象（native objects）的区别是什么？

* 原生对象：是由 ECMAScript 规范定义的 JavaScript 内置对象，比如String、Math、RegExp、Object、Function等等。
* 宿主对象：是由运行时环境（浏览器或 Node）提供，比如window、XMLHTTPRequest等等。

## 如何在改变一个对象的属性时对其进行拦截。

``` js
  const obj = {}
  let bValue = ''
  Object.defineProperty(obj, "b", {
      get: function() {
          return bValue + 10;
      },

      set: function(newValue) {
          console.log('newValue', newValue)
          bValue = newValue;
      }
  });
  obj.b = 3;
  console.log(';2323', obj)
```

## 数据属性和访问器属性的区别

## JS中如何自定义事件。

### 1. CustomEvent

``` js
  let customEvent = new CustomEvent('customEventName', {
      detail: {
          a: 1
      }
  })
  document.dispatchEvent(customEvent)
  document.addEventListener('customEventName', e => {
      console.log(e)
      console.log(e.detail.a) // 1
  })
```

### 2.createEvent

``` js
let ev = document.createEvent('CustomEvent')
ev.initCustomEvent('ev', false, true, {
    b: 2
})
document.dispatchEvent(ev)
document.addEventListener('ev', e => {
    console.log(e)
    console.log(e.detail.b) // 2
})
```

## JS中0.1 + 0.2 不等于0.3的具体原因是什么， 如何解决这个问题？

## flat函数

## 找出数组中和为给定值的两个元素，如：[1, 2, 3, 4, 5]中找出和为6的两个元素。

## 闭包
闭包的定义：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

``` js
function A() {
    let a = 1
    window.B = function() {
        console.log(a)
    }
}
A()
B() // 1
```
### 场景有：

1. 函数式编程，compose curry
1. 函数工厂、单利
1. 私有变量和方法，面向对象编程

> 意义: 1. 就是让我们可以间接访问函数内部的变量。2. 让这些变量的值始终保持在内存中


## 什么是尾递归？
递归函数：函数内部循环调用自身的就是递归函数，若函数没有执行完毕，执行栈中会一直保持函数相关的变量，一直占用内存，当递归次数过大的时候，就可能会出现内存溢出，也叫爆栈，页面可能会卡死。
所以为了避免出现这种情况，可以采用尾递归。
尾递归：在函数的最后一步是调用函数，进入下一个函数不在需要上一个函数的环境了，内存空间 O(n) 到 O(1) 的优化 ，这就是尾递归。
尾递归的好处：可以释放外层函数的调用栈，较少栈层级，节省内存开销，避免内存溢出。
网上很多用斐波那契数列作为栗子，但我偏不，我用个数组累加的栗子
```js
function add1(arr) {
    if (arr.length === 0) {
        return 0
    }
    return add1(arr.slice(1)) + arr[0] // 还有父级函数中 arr[0] 的引用
}

function add(arr, re) {
    if (arr.length === 0) {
        return re + 0
    } else {
        return add(arr.slice(1), arr[0] + re) // 仅仅是函数调用
    }
}

console.log(add([1, 2, 3, 4], 0))  // 10
console.log(add1([1, 2, 3, 4])) // 10
```

## ES5/ES6的实现类的区别还有什么区别？

1. 严格模式： 类和模块的内部，默认就是严格模式，
2. 不存在提升
3. class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
4. class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用
5. 必须使用 new 调用 class。
6. class 内部无法重写类名。

## setTimeout 经典问题

``` js
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i)
    }, i * 1000)
}
// 输出结果：输出一堆 6。
```

#### 输出1, 2, 3, 4, 5方法

* 方法1, 闭包

``` js
for (var i = 1; i <= 5; i++) {
    ;
    (function(j) {
        setTimeout(function timer() {
            console.log(j)
        }, j * 1000)
    })(i)
}
```

* 方法2，setTimeout第三个参数

``` js
for (var i = 1; i <= 5; i++) {
    setTimeout(
        function timer(j) {
            console.log(j)
        },
        i * 1000,
        i
    )
}
```

* 方法3， let方法

``` js
for (let i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i)
    }, i * 1000)
}
```

## js垃圾回收的方法有哪些

### 1. 标记清除（mark-and-sweep）
目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存

### 2. 引用计数

引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。

> V8 的垃圾回收策略主要基于分代式垃圾回收机制。所谓分代式，就是将内存空间分为新生代和老生代两种，然后采用不同的回收算法进行回收。[查看详细](https://www.jianshu.com/p/7e74b6dcde69)

## js延迟加载的方式有哪些， defer和async的区别

### 1.defer属性
这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在 `<script>` 元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。

### 2.async属性

同样与defer类似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer不同的是，标记为async的脚本并不保证按照指定它们的先后顺序执行。

### 3. 动态创建DOM方式

``` js
function downloadJSAtOnload() {
    varelement = document.createElement("script");
    element.src = "defer.js";
    document.body.appendChild(element);
}
```

### 4. 放body底部

## 事件委托
用于处理“事件处理程序过多”问题，利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。

### 优点：

1. 只添加一个事件处理程序所需的DOM引用更少，所花的时间也更少。
2. 整个页面占用的内存空间更少，能够提升整体性能。
3. 如果是给document对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序（无需等待DOMCon-tentLoaded或load事件）

## bind, call, apply解释

### 一、函数4种调用的方式

* 1. 函数模式
* 2. 方法模式
* 3. 构造函数模式
* 4. 上下文模式(也有叫apply模式)

### 二、apply, call, bind用法

在JavaScript 中，call、apply 和 bind 是 Function 对象自带的三个方法，这三个方法的主要作用是改变函数调用过程中的 this 指向

#### 1.apply(thisArgs, [argsArray])

* 第一个参数：指定函数体内this对象的指向

  thisArgs 的取值有以下4种情况：

  + 不传，或者传 `null` , `undefined` ， **非严格模式下** 函数中的 `this` 指向 `window` 对象。 **严格模式**下 `不传` 、 `undefined` 函数中 `this` 指向 `undefined` 。 `传入null` 函数中 `this` 指向 `null`
  + 传递另一个函数的函数名，函数中的 `this` 指向这个函数的引用
  + 传递字符串、数值或布尔类型等基础类型，**非严格模式**函数中的 `this` 指向其对应的包装对象，如 `String` 、 `Number` 、 `Boolean` 。**严格模式**，指向传入的值
  + 传递一个对象，函数中的 `this` 指向这个对象
* 第二个参数：可以是数组或类数组, apply方法把这个集合中的元素作为参数传递给被调用的函数

``` javascript
var func = function(a, b, c) {
    console.log([a, b, c]); // [1,2,3]
}
func.apply(null, [1, 2, 3])
```

#### 2.call(thisArgs, arg1, arg2, ... )

* 第一个参数thisArgs： 的取值跟apply一样
* 后面是个参数列表 `arg1, arg2, ...`

``` javascript
function a() {
    console.log(this); //输出函数a中的this对象
}

function b() {} //定义函数b

var obj = {
    name: 'onepixel'
}; //定义对象obj
// 严格模式
a.call(); //undefined
a.call(null); //null
a.call(undefined); //undefined
a.call(1); //1
a.call(''); // ''
a.call(true); //true
a.call(b); // function b(){}
a.call(obj); //Object
// 非严格模式
a.call(); //window
a.call(null); //window
a.call(undefined); //window
a.call(1); //Number
a.call(''); //String
a.call(true); //Boolean
a.call(b); // function b(){}
a.call(obj); //Object
```

> 当使用call或则apply的时候，如果我们传入的第一个参数是null．函数体内的this会指向默认的宿主对象，在游览器中则是window

``` javascript
var func = function(a, b, c) {
    alert(this === window); // 输出true
};
func.apply(null, [1, 2, 3]);
```

> 但如果是在严格模式下，函数体内的this还是为null：

``` javascript
var func = function(a, b, c) {
    "use strict";
    alert(this === null); // 输出true
}
func.apply(null, [1, 2, 3]);
```

有时候我们使用call或者apply的目的不在于指定this指向，而是另有用途，比如借用其他对象的方法。
那么我们可以传入null来代替某个具体的对象：
`Math.max.apply( null, [ 1, 2, 5, 3, 4 ] )    // 输出：5`

> apply 和 call 的唯一区别是第二个参数的传递方式不同，apply 的第二个参数必须是一个数组，而 call 允许传递一个参数列表。值得你注意的是，虽然 apply 接收的是一个参数数组，但在传递给调用函数时，却是以参数列表的形式传递，我们看个简单的例子：

### 3.bind(thisArgs, arg1, arg2, ... )

bind是ES5 新增的一个方法，它的传参和call类似，但又和 call/apply 有着显著的不同，即调用 call 或 apply 都会自动执行对应的函数，而 bind 不会执行对应的函数，只是返回一个原函数的拷贝，并拥有指定的this值和初始参数。

```js
var obj = {name:'onepixel'};
/**
 * 给document添加click事件监听，并绑定onClick函数
 * 通过bind方法设置onClick的this为obj，并传递参数p1,p2
 */
document.addEventListener('click',onClick.bind(obj,'p1','p2'),false);

//当点击网页时触发并执行
function onClick(a,b){
  console.log(
    this.name, //onepixel
    a, //p1
    b  //p2
  )
}
```

## CMD、AMD、CommonJS、ES Modules说明

## 高阶函数说明

高阶函数定义：

* 以一个函数作为参数
* 以一个函数作为返回结果

### 1. 高阶函数捕获参数

##### 为啥需要创建一个以函数为返回值的函数？
高阶函数的参数是用来“配置”返回函数的行为的。
eg： makeAdder, 它参数配置了其返回函数每次添加数值的大小

```js
var add100 = makeAdder(100);
add100(40) // => 140
```

通过将函数makeAdder的返回函数命名为add100， 这里特别强调了返回函数是如何被"配置"的。 这是非常有用的，但其能力有限。不同的是， 经常会看到一个函数返回一个捕获变量的函数。

### 2. 捕获变量的好处

假如需要一个生产唯一字符串的函数

```js
function uniqueString(len) {
  return Math.random().toString(36).substr(2, len);
}
uniqueString(10); // => '3rms32dsx'
```

然而，如果要生成具有特定前缀的唯一字符串，怎么办? 可将uniqueString修改为

```js
function uniqueString(prefix) {
  return [prefix, new Date().getTIme()].join('');
};
uniqueString('test')
uniqueString(10); // => 'test3rms32dsx'
```

如果需要再次变更， 需要返回一个添加了前缀，并且从某一个值开始增长的字符串，这种情况下，上述方法就不行了。 具体效果如下

```js
uniqueString('ghosts'); // => 'ghosts0'
uniqueString('test'); // => 'test1'
```

实现如下

```js
function makeUniqueStringFunction(start) {
   let count = start;
  return (prefix)=>[prefix, count++].join('');
}
var uniqueString = makeUniqueStringFunction(0);

uniqueString('ghosts'); // => 'ghosts0'
uniqueString('test'); // => 'test1'
```

> makeUniqueStringFunction 使用了conut的变量来追踪当前值。 虽然对于外界操作来说，该变量是安全的， 但是它的存在会增加复杂度，当一个函数的返回值只依赖于它的参数时， 被称为：**引用透明**。 实际当中我们应该尽量避免这样的函数， 除非他们是绝对必要的。

## 浅比较or深比较

1. `浅比较` :（也被称为 `引用相等` ）只检查两个不同 变量 是否为同一对象的引用；与之相反，

2. `深比较` :（也被称为 `原值相等` ）必须检查两个对象所有属性的 值 是否相等。

> 所以，浅比较就是简单的（且快速的）a === b，而深比较需要以递归的方式遍历两个对象的所有属性，在每一个循环中对比各个属性的值。

## promise

`Promise` 是异步编程的一种解决方案, ES6 原生提供了Promise对象。简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）

### 1. 特点：

* (1). 对象的状态不受外界影响, 三种状态： `pending（进行中）` 、 `fulfilled（已成功）` 、 `rejected（已失败)`
* (2). 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected

### 2. 缺点：

* (1). 无法取消Promise，一旦新建它就会立即执行，无法中途取消。
* (2). 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
* (3). 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

### 3. Promise中 .then的第二个参数与.catch有什么区别

`.catch` 写法可以捕获前面then方法执行中的错误.

``` js
// bad
promise
    .then(function(data) {
        // success
    }, function(err) {
        // error
    });

// good
promise
    .then(function(data) { //cb
        // success
    })
    .catch(function(err) {
        // error
    });
```

> 一般不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。


## 浏览器的事件循环和nodejs事件循环的区别


## 数组常用方法， 数组怎么去重

## 图片懒加载如何实现

## js的sort方法内部使用的什么排序

> 各游览器引擎实现方式有区别

### Mozilla/Firefox : 归并排序（jsarray.c 源码）

### Webkit
底层实现用了 C++ 库中的 qsort() 方法（JSArray.cpp 源码）: http://trac.webkit.org/browser/trunk/Source/JavaScriptCore/runtime/JSArray.cpp#L428

### v8

sort源码： https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js

``` js
// In-place QuickSort algorithm.
// For short (length <= 22) arrays, insertion sort is used for efficiency
```

v8 InsertionSort 和 QuickSort，数量小于22的数组使用 InsertionSort，比22大的数组则使用 QuickSort。

## 用JavaScript的异步实现sleep函数

### es5 简易版

``` js
console.log('start...');
console.log('now time: ' + Date(/\d{10,10}/.exec(Date.now())));

function sleep(sleepTime) {
    for (var start = Date.now(); Date.now() - start <= sleepTime;) {}
}
sleep(5000); // sleep 5 seconds
console.log('end...');
console.log('end time: ' + Date(/\d{10,10}/.exec(Date.now())));
```

### es6 简易版

``` js
function sleep(interval) {
    return new Promise(resolve => {
        setTimeout(resolve, interval);
    })
}

// 用法
async function one2FiveInAsync() {
    for (let i = 1; i <= 5; i++) {
        console.log(i);
        await sleep(1000);
    }
}

one2FiveInAsync();
```

## 检测数组的方式

``` js
value instanceof Array

Array.isArray()(es5)

Object.prototype.toString.call()
```

## sessionStorage, localStorage, cookie 区别

1. 都会在浏览器端保存，有大小限制，同源限制
2. cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器
3. cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie
4. 有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除
5. 共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享
6. localStorage 的修改会促发其他文档窗口的 update 事件
7. cookie 有 secure 属性要求 HTTPS 传输
8. 浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M

