# HTTP

## HTTP的历史
当前广泛使用的版本HTTP/1.1, 2015年又推出HTTP/2，但是要完全取代HTTP/1.1成为主流还需要漫长的时间

## HTTP 协议的内容
一次HTTP协议通信会由客户端发起请求报文，然后由服务器端返回响应报文，而请求报文和响应报文的结构大致相同
请求报文包含请求行、请求头部、请求体

分类 | 值
---|---
请求行： |  请求方法、URL、协议版本
请求头部 | 头部字段名： 值
数据 | 请求体

### 请求头部
`key：value`的形式，中间以冒号相隔，其中字段名不区分大小写。
#### 头部字段类型分为4种
##### 一、 通用头部字段
1. `Cache-Control:`
控制缓存的，它可以接收多个参数，参数之间以逗号“，”分隔。虽然它是通用字段，但是请求头部和响应头部使用的参数值还是略有不同。
  * `no-cache：` no-cache值表明强制使用最新的值而不使用缓存值。则表示客户端不接收缓存过的响应，缓存服务器必须把客户端请求转发给源服务器。如果响应中包含no-cache，那么缓存服务器不能对响应资源进行缓存。
  * `no-store：` 当使用no-store时表示对应的报文中包含机密信息，也就意味着不应该缓存当前内容。
  * `no-transform：` 缓存不能改变主体的媒体类型，能防止缓存服务器压缩图片等操作。
  * `max-age：` 缓存有效期，单位为“秒”。客户端请求中包含max-age时，如果缓存资源的缓存时间比指定时间数值更小时则接收缓存资源，当值为0时，缓存服务器会把请求转发给源服务器。当响应报文中包含max-age，缓存服务器不再确认资源的有效性，而以max-age数值作为缓存保存时长。
  * `min-fresh：` 数值，单位为“秒”。要求缓存服务器在指定的时间内返回响应。
  * `only-if-cached：` 客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回值，也就是说不会向源服务器转发请求。响应头部常使用的值介绍如下。
  * `must-revalidate：` 本地缓存过期前可以使用，否则必须进行有效性校验。
  * `public：` 响应可被任何对象缓存，没有限制。
  * `private：` 响应只能被特定用户缓存，不能被其他用户使用。
  * `proxy-revalidate：` 仅适用于共享缓存，私有缓存时忽略。
  * `must-revalidate：` 缓存必须在使用之前验证旧资源的状态，如果过期则不可使用。

2. `Connection:`
* `Close` 当一方头部Connection值为Close时，代表关闭此次连接。
* `Keep-Alive` HTTP/1.1版本默认连接是持久的。对于之前的版本，需要指定值为Keep-Alive。

3. `Date:` 报文创建的时间日期。

##### 二、请求头部
1. `accept:` 先看看一个HTTP请求头部accept字段的值，我们对照它进行分析：`accept:text/html,application/xhtml+xml,ap-plication/xml;q=0.9,image/webp,*/*;q=0.8accept`字段可以设置多个值，每个值通过逗号“，”分隔（而不是分号“；”）
常见MIME类型与子类型

![](./img/img14.png )

2. `accept-charset:`
告知服务单客户端可以处理的字符集类型

3. `accept-encoding:` 客户端能够接收的编码方式，通常这个字段值会是某种压缩算法，比如gzip、compress。这个字段也支持权重设置，设置规则同accept。
4. `accept-language:` 客户端可以解析的自然语言，可以一次指定多个语言并设置权重，常用的值有zh-cn和en-us。
5. `authorization:` 用来告知服务器端认证信息。通常会在收到401状态码之后，在请求头部加入此字段，它的值是：type credentials
6. `host:` 用来告知服务器端请求资源所处的互联网主机名和端口号，如果不指定端口则会使用默认端口。这是唯一一个请求头部的必传字段。
7. `if-modified-sinceif-modified-since`: 这个字段值通常是一个日期，用来确认代理或客户端本地资源的有效性。服务器端在接收这个值后会与资源最近更新时间进行对比，如果在字段值指定的日期之后资源发生了更新，则服务器端会返回最新的资源，否则将返回304状态码响应客户端。
8. `if-none-match` 用于判断本地缓存是否有效。`if-none-match`通常存储的是上一次响应头部的`ETag`值，指定的值与资源的`ETag`值不一致时，服务器端才会处理请求。

##### 二、响应头部字段
1. `age:` 字段值为数值，单位为秒，该字段能告知客户端服务器端在多久前创建了响应，若创建该响应的是缓存服务器，age值指的是缓存后的响应再次发起认证到认证完成的时间。代理创建响应必须加上age字段。
2. `ETag:` 服务器端在每次资源更新之后，都会生成一个唯一对应的标识，这个标识就是ETag值。ETag值的生成算法由服务器端自行决定，并没有统一的要求。ETag中有强ETag和弱ETag之分。强ETag只要资源发生变化就会改变值，而弱ETag值只用于提示资源是否相同。只有资源发生了较大改变的时候才会改变ETag值。它们可以通过值的格式来进行区分，弱ETag值相对于强ETag值会加上W/来表示。强ETag："asdfc12312"弱ETag：W/"asdfc12312"
3. `location:` 使用头部字段location可以引导请求发起方至某个与请求URL位置不同的资源，一般会配合3xx的状态码进行使用，比如302。
4. `www-authenticate:` 用于告知客户端当前服务器端可接收的认证方案，然后客户端可在authentication字段值中返回对应的值。

##### 三、主体头部字段
主体头部字段是包含在请求报文和响应报文中的主体部分所使用的头部，用于补充与主体相关的信息。
1. `allow:` 用于通知客户端能够支持的HTTP请求方法。当服务器端接收到不支持的HTTP请求方法时，会响应状态信息405 Method Not Allowed，同时把支持的方法写入allow字段。
2. `content-encoding`: 用于告知客户端当前响应内容的编码方式，和请求头部字段accept-encoding的可选值一致，主要采用4种编码方式：gzip、compress、deflate、identity。3. `content-length表明主体部分的大小，单位为字节。
4. `content-type:` 与请求头部字段accept对应，表明响应主体内容的MIME类型。
5. `last-modified:` 资源的最后修改时间。同样是和缓存配合使用。
6. `expires:` 值为失效日期，缓存服务器在接收到含有头部字段`expires`的响应之后，会以缓存来应答请求，在expires值指定的日期之前，响应的值会一直被缓存，如果过期则在收到新的请求之后重新向源服务器发起请求。当头部`cache-control`值有`max-age`时，优先处理`max-age`。

#### 四、 其他字段
HTTP的头部信息是可以自定义的，服务器端和客户端都可以根据需要进行扩展。例如，
 * `X-Frame-Options`就常作为响应头部字段，用来表示网站内容是否允许被嵌入其他网站的`iframe`中。当其值为deny时就表示禁止被作为iframe嵌入，这样可以有效地防止常见的点击劫持。

### Cookie
#### 请求报文中为cookie，响应报文中为set-cookie。
在set-cookie字段值中采取“名称=值”的形式，同时可以搭配属性来对其进行描述，可以使用的属性值包括下面5个。
1. `expires:` 通过这个属性可以指定数据的有效期，如果不设置此属性，那么当浏览器关闭的时候Cookie则会被清除。当Cookie从服务器端发出之后，就无法直接删除，只能通过覆盖已过期的Cookie来进行删除操作。
2. `path:` 用于指定Cookie发送范围的路径。如果不指定则为根路径。
3. `domain:` 指定Cookie适用的域名，匹配规则为结尾匹配，比如指定baidu.com之后，那么map.baidu.com、music.baidu.com域名都可以发送该Cookie。
4. `secure:` 当使用secure属性时表示只能在HTTPS安全连接中使用。没有此属性时，HTTP协议和HTTPS协议都可以操作该Cookie。
5. `HttpOnly:` 设置了该属性后浏览器端的JavaScript脚本程序将无法获得Cookie内容，从而无法轻易修改或删除。其主要目的是为了防止跨站脚本（XSS）对Cookie信息的窃取。

#### Cookie的缺陷
* Cookie的大小是有限的，不同浏览器的限制会有所不同，早期浏览器对Cookie的限制大约在4KB左右，这就意味着客户端能存取的状态信息是非常有限的。
* Cookie会消耗网络带宽，因为Cookie是跟随域名和路径设定的，只要域名和路径相同，对于某些不需要Cookie的请求也会带上Cookie。
* Cookie是可以被禁用的，如果浏览器设置了安全策略禁止使用Cookie，那么服务器端设置Cookie将会失败。
* Cookie可能会被窃取或篡改。

## HTTP/2 新功能
1. 多路复用： 在`HTTP/1.1`协议中，为了避免浏览器过度消耗服务器端资源，所以限制了浏览器针对同一域名的并发请求数量，不同浏览器的限制数量在4～8不等，超过限制数量的请求将会被阻塞，延迟发送。`HTTP/2` 则都是同时发送
2. 压缩报文：`HTTP/2`启用了强制性的压缩算法来压缩报文
3. 支持`TLS`: `HTTP/1.1`由于无法保障数据的安全性，所以有了其升级版`HTTPS`协议，而`HTTP/2`中允许使用`TLS 1.2`或更新版本的协议来进行加密，使得通信更加安全。
4. 应用层协议协商: 支持应用层协议协商（Application Layer Pro-tocol Negotiation，ALPN），以便客户端能够从HTTP/1.0、HTTP/1.1、HTTP/2乃至其他非HTTP协议中做出选择。
5. 服务器端推送
6. 流控制: 是接收端可以告知发送端能接收的数据大小，发送端在发送时进行计算，发送不超过设定值的数据。


## http method都要哪些， 区别
HTTP/1.1包含: `get` `head` `post` `options` `put` `delete` `trace` `connect`"
### 安全方法（Safe Methods）:
是指用户不管进行多少次操作，资源的状态都不会改变。比如说，`GET`和`HEAD`方法仅能获取资源，而不会执行动作（action），这些方法属于“安全”的方法。
而`POST`，`PUT`，`DELETE`方法改变了资源的状态，可能会执行不安全的动作，使用者应该意识到这一点。
